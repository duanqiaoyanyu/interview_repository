**红锁 算法**
在这个算法的分布式版本中, 我们假定我们有 `N` 个 Redis 主节点. 这些节点是完全独立的, 所以我们不使用 `复制` 或者 任何其他的 `内隐协调` 系统.  
我们已经描述了如何在单实例中安全地获得和释放锁. 我们保证这个算法将会使用这个方法在单实例中去获取和释放锁. 在我们的例子中, 我们设置 `N = 5`, 这是一个  
合理的值, 所以我们需要在不同的电脑或者虚拟机上运行 5 个 Redis 主节点 为了确保他们将会相互独立  

为了去获取锁, 客户端表现下列的操作:
1. 获取当前时间毫秒值 `t1`.
2. 试图在 `N` 个实例顺序地获取锁, 在所有的实例中使用同样的 `key` 名字 和 `随机值` . 在第二步中, 当在每一个实例中设置锁的时候, 客户端使用一个 `timeout`  
去拿锁. 这个 `timeout` 和 整个锁的自动释放时间(`auto-release`) 时间相比要小的多. 举个例子如果自动释放时间是 `10s`, 超时时间就可能是在 `5~50`毫秒这个范围.  
这个防止客户端试图与一个 `down` 了的 Redis 节点通信长时间的阻塞. 如果一个实例不可用, 我们应该尽可能快地与下一个实例通信.
3. 客户端计算出为了拿到锁过去多少时间`t3`, 通过当前时间 `t2` 减去 第一步拿到的时间戳 `t1`. 当且仅当客户端能够在大多数实例中(至少 3 个)中获取锁, 整个拿锁过去的时间 `t3 = (t2 -t1)` 
是比锁的有效时间`t4`(≈ `auto-release`)要短的, 这个锁才被认为是拿到了.
4. 如果锁被拿到了, 它的有效时间`t5`被认为应该是最初的有效时间`t4`减去`t3`(第三步计算出来的过去了的时间) `t5 = t4 - t3;`
5. 如果客户端因为某些原因(要么是不能在 `N/2+1`个实例上拿到锁, 要么就是有效时间`t5`是负数)拿到锁失败, 它将会试图将所有的实例解锁(即使这个实例不能拿到锁).




参考文档:
1. https://redis.io/docs/reference/patterns/distributed-locks/#the-redlock-algorithm
