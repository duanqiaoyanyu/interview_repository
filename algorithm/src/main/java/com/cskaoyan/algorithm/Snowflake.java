package com.cskaoyan.algorithm;

/**
 *
 * <p>
 *     64 位
 *     构成 1 + 41 + 5 + 5 + 12
 *     1位是第一位, 无实际意义. 固定是 0
 *     41位是 时间戳
 *     5位机器ID 5位数据中心, 也就是 1024 个数据节点
 *     12位是 1毫秒内可以产生的序列号 4096个 0-4095
 * </p>
 *
 * 时间回拨问题
 * 在获取时间的时候, 可能会出现 **时间回拨**的问题, 什么是时间回拨问题呢? 就是服务器上的时间突然倒退到之前的时间.
 * 1. 认为原因, 把系统环境的时间改了
 * 2. 有时候不同的机器上需要同步时间, 可能不同机器之间存在误差, 那么可能会出现时间回拨问题.
 *
 * 解决方案
 * 1. 回拨时间小的时候, 不生成 ID, 循环等待到时间点到达.
 * 2. 上面的方案只适合时钟回拨较小的, 如果间隔过大, 阻塞等待, 肯定是不可取的, 因此要么超过一定大小的回拨直接报错, 拒绝服务, 或者有一种方案是
 * 利用拓展位, 回拨之后在拓展位上加1就可以了, 这样ID依旧可以保持唯一. 但是这个要求我们提前预留出位数, 要么从机器id中, 要么从序列号中, 腾出一定
 * 位, 在时间回拨的时候, 这个位置+1.
 *
 * 参考资料:
 * 1. https://zhuanlan.zhihu.com/p/85837641
 * 2. https://segmentfault.com/a/1190000040964518
 * 3. https://cloud.tencent.com/developer/article/1772047
 *
 * @author duanqiaoyanyu
 * @date 2022/12/23 16:39
 */
public class Snowflake {
}
