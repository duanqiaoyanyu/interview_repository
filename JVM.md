

怎么选择垃圾回收器?
- 优先让 `JVM` 自适应, 调整堆的大小
- 串行收集器: 内存小于 100M; 单核、单机机器, 并且没有停顿时间的要求
- 并行收集器: 多 `CPU`、 高吞吐量、允许停顿时间超过 1 秒
- 并发收集器: 多 `CPU`、追求低停顿时间、快速响应(比如延迟不能超过 `1秒`, 如互联网应用)
- 官方推荐 `G1`, 性能高。现在互联网的项目, 基本都是使用 `G1`

特别说明:
- 没有最好的收集器, 更没有万能的收集器
- 调优永远是针对特定场景、特定需求，不存在一劳永逸的收集器

七款垃圾收集器
1. 串行回收器: `Serial`、 `Serial Old`
2. 并行回收器: `Parnew`、 `Parallel Scavenge`、 `Parallel Old`
3. 并发回收器: `CMS`、`G1`

- 新生代收集器: `Serial`、`Parnew`、`Parallel Scavenge`;
- 老年代收集器: `Serial Old`、 `Parallel Old`、 `CMS`;
- 整争堆收集器: `G1`;

垃圾收集器比较
---
| 垃圾收集器 | 分类 | 作用位置 | 使用算法 | 特点 | 适用场景 |
| :- | :-: | :-: | :-: | :-: | :- |
| Serial | 串行运行 | 作用于新生代 | 复制算法 | 响应速度优先 | 适用于单 CPU 环境下的 client 模式 |
| ParNew | 并行运行 | 作用于新生代 | 复制算法 | 响应速度优先 | 多 CPU 环境 Server模式下与CMS配合使用 |
| Parallel | 并行运行 | 作用于新生代 | 复制算法 | 吞吐量优先 | 适用于后台运算而不需要太多交互的场景 |
| Serial Old | 串行运行 | 作用于老年代 | 标记-压缩算法 | 响应速度优先 | 适用于单 CPU 环境下的 client模式 |
| Parallel Old | 并行运行 | 作用于老年代 | 标记-压缩算法 | 吞吐量优先 | 适用于后台运算而不需要太多交互的场景 |
| CMS | 并发运行 | 作用于老年代 | 标记-清除算法 | 响应速度优先 | 适用于互联网或 B/S 业务 |
| G1 | 并发、并行运行 | 作用于新生代、老年代 | 标记压缩算法、复制算法 | 响应速度优先 | 面向服务端应用 |

怎么选择垃圾回收器: 
Java 垃圾收集器的配置对于 JVM 优化来说是一个很重要的选择, 选择合适的垃圾手机器可以让 JVM 的性能有一个很大的提升。怎么选择垃圾收集器? 
1. 优先调整堆的大小让 JVM 自适应完成
2. 如果内存小于 100M, 使用串行收集器
3. 如果是单核、单机机器, 并且没有停顿时间的要求, 串行收集器
4. 如果是多 CPU、需要高吞吐量、允许停顿时间超过1秒, 选择并行或者JVM自己选择
5. 如果是多 CPU、追求停顿时间, 需快速响应(比如延迟不能超过1秒, 如互联网应用), 使用并发收集器
6. 官方推荐 G1, 性能高. 现在互联网的项目, 基本都是使用 G1.
