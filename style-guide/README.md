### 2 源文件基础
#### 2.1 文件名  
    源文件名由大小写敏感的顶级类组成, 加上 `.` 作为扩展
#### 2.2 文件编码: UTF-8  
    源文件用 UTF-8 进行编码
#### 2.3 特殊字符
##### 2.3.1 空白字符
    除了行终止符序列, `ASCII` 水平空白字符 (`0x20`) 是唯一出现在源文件中的空白字符. 这意味着:  
    1. 所有的在字符串和字面量里的其他空白字符都被转义
    2. `Tab` 符不用于缩进

##### 2.3.2 特殊转义序列
对于有特殊转义序列(`\b`, `\t`, `\n`, `\f`, `\"` `\\`)的字符, 使用转义序列而不是响应的八进制(e.g. `\012`) 或者 Unicode(e.g. `\u000a`) 转义

##### 非 ASCII 字符
对于剩余的 非ASCII 字符, 要么实际的 Unicode 字符(e.g. `∞`) 或者同样的 Unicode 转义(e.g. `\u221e`)使用. 选择取决于哪个使得代码更易读和理解,
尽管 Unicode 转义外部字符串字面值和注释是十分不推荐的

> 在 Unicode 转义, 偶然甚至当 Unicode 字符使用, 一个解释性的注释会非常有帮助

例子:

| Example                                                                                                                 | Discussion                                                                |
|:------------------------------------------------------------------------------------------------------------------------|:--------------------------------------------------------------------------|
| String unitAbbrev = "μs";	                                                                                              | Best: perfectly clear even without a comment.                             |
| String unitAbbrev = "\u03bcs"; // "μs"                                                                                  | Allowed, but there's no reason to do this.                                |
| String unitAbbrev = "\u03bcs"; // Greek letter mu, "s"                                                                  | Allowed, but awkward and prone to mistakes.                               |
| String unitAbbrev = "\u03bcs";                                                                                          | Poor: the reader has no idea what this is.                                |
| return '\ufeff' + content; // byte order mark | Good: use escapes for non-printable characters, and comment if necessary. |

> 永远不要使得你的代码更少的可读性, 简单有些项目或许不处理 非ASCII 字符, 如果那应该发生, 这些项目就坏了并且必须被修复

### 3 源文件结构
    一个源文件组成, 按顺序  
    1. 执照或者版权信息, 如果存在  
    2. 包陈述  
    3. 导入陈述  
    4. 确切的一个顶级类  
    **精确一个空白行**分隔每一个部分  

#### 3.1 执照或者版权信息, 如果存在
    如果执照或者版权信息属于一个文件, 它应该属于这里
#### 3.2 包陈述
    包陈述是不换行的. 列限制(4.4节, 列限制: 100) 不适用于导包语句
#### 3.3 导入语句
##### 3.3.1 没有通配符导入
    通配符导入, 静态或者其他, 不使用的
##### 3.3.2 没有换行
    导入语句是不换行的. 列限制(4.4节, 列限制: 100) 不适用于导入语句
##### 3.3.3 排序和空格
    导入的顺序如下:  
    1. 所有的静态导入单独一块  
    2. 所有的非静态导入在单独一块  
    如果这里既有静态又有非静态导入, 单独一个空白行分隔两块. 导入语句之间没有其他的空白行  
    在每一块导入的名字以 ASCII 顺序(注意: 这不是同样重要语句按照 ASCII 顺序, 因为 '.' 排在 ','前面)

##### 3.3.4 没有静态类导入
静态导入不用于静态嵌套类. 他们通过正常导入

#### 3.4 类声明
##### 3.4.1 明确的一个顶级类声明
    每一个顶级类驻留在它自己的源文件中

##### 3.4.2 类内容的排序
你对你的类的成员和初始值选择的顺序会对可学习性有重大影响. 然而, 没有一个单独的正确方法说怎么做; 不同的类或许排序他们的内容用不同的方式.  
重要的是每一个类使用 `一些逻辑顺序`, 被问到的时候它维护者可以解释, 举个例子, 新方法不要只是习惯性地添加到类的最后面, 因为这会产生按照日期添加的顺序,
这不是一个逻辑顺序

##### 3.4.2.1 重载: 从不撕裂
共享相同名称的类的方法出现在一个连续的组里, 中间没有其他成员. 同样应用于多个构造器(经常有同样的名字). 这条规则运用即使当修饰符 比如 `static` 或者
`private` 在方法间不同.

### 格式
    **术语说明**: 块状构造涉及到类的 body, 方法或者构造器. 通过 4.8.3.1 节 在数组初始化器, 任意数组初始化器或许可选择性地被认为是一个块状构造

#### 4.1 括号
##### 4.1.1 可选括号的使用
    括号与 `if`, `else`, `for`, `do`, 和 `while` 语句一起使用时, 即使当语句体时空的或者只包含一个单句  
    其他可选括号, 比如在一个 `lambda` 表达式, 仍然是可选的

##### 4.1.2 非空块: K & R 风格
    括号遵循 Kernighan 和 Ritchie 风格("Egyptian brackets") 对于非空块和块状构造  
        - 在左大括号之前没有换行符, 除了以下详细描述的
        - 在开始括号后换行
        - 在结束括号前换行
        - 仅当该括号终止语句或者终止方法、构造方法、或命名类的主体时, 才在结束括号后面换行. 例如, 如果括号后面跟着 else 或 逗号, 则括号后面没有换行  

异常: 有些时候这些规则允许一个以 `;` 结尾的单句, 一块语句可以出现, 并且这块语句的开始括号前面有一个换行符. 像这样的块时典型的介绍的限制本地变量的作用范围,
举例里面有一些 switch 语句  

例子:
```java
return () -> {
  while (condition()) {
    method();
  }
};

return new MyClass() {
  @Override public void method() {
    if (condition()) {
      try {
        something();
      } catch (ProblemException e) {
        recover();
      }
    } else if (otherCondition()) {
      somethingElse();
    } else {
      lastThing();
    }
    {
      int x = foo();
      frob(x);
    }
  }
};
```
一些枚举类的异常情况在 4.8.1节中给出  
##### 4.1.3 空块: 可能简洁
    一个空快或者块状构造可能会是 K & R 风格(在 4.1.2节描述的一样) 或者, 它在它开始之后应该立即结束, 没有字符或者在之间只有换行符(`{}`), 除非它是一个
多块语句的一部分(直接包含多块语句: `if/else` 或者 `try/catch/finally`)  
例子:
```java
  // This is acceptable
  void doNothing() {}

  // This is equally acceptable
  void doNothingElse() {
  }
```

```java
  // This is not acceptable: No concise empty blocks in a multi-block statement
  try {
    doSomething();
  } catch (Exception e) {}
```

#### 4.2 块缩进: +2 空格
    每次一个新块或者一个块状构造开启, 缩进增加了两个空格. 当块结束的时候, 缩进返回到之前的缩进水平. 缩进水平适用于整个快的代码和注释.(看 4.1.2 节
的例子, 非空块 K & R 风格)

#### 4.3 每行一个语句
    每一个语句后面跟着一个换行

#### 4.4 列限制: 100
    Java 代码有一个列限制 100 字符数. 一个 "字符" 意味着任意 Unicode 代码点. 就像下面期盼的那样, 任意超过这个限制的行都必须换行, 就像 4.5节
解释的那样, 换行  
> 任意 Unicode 代码点计数作为一个字符, 即使它的展示宽度是更大或者更小. 举个例子, 如果使用全宽字符, 你可以选择这个规则严格要求的更早进行换行  

异常:
1. 不可能遵守列限制的行(举例, 一个 Javadoc 中的长 URL, 或者一个长的 JSNI 方法引用)
2. `包` 和 `导入` 语句(见 3.2节 包语句 和 3.3节 导入语句)
3. 注释中的命令行可能会被拷贝和粘贴进 shell
4. 非常长的缩进, 很少地偶然他们被调用, 允许去超过这个列限制. 在这种情况下, 周围代码合理的换行是由 google-java-format 生产的
