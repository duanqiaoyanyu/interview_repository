### 线程池
创建线程的方法通过 


1. 线程异常处理 https://blog.csdn.net/pange1991/article/details/82115437


线程池的执行流程如下:
1. 创建线程池对象: 使用线程池的实现类(例如 `ThreadPoolExecutro` 或者 `ScheduledThreadPoolExecutor`) 创建一个线程池对象, 并置顶线程池的参数,
如核心线程数、最大线程数、工作队列类型、线程空闲时间等。
2. 提交任务: 将需要执行的任务提交给线程池. 任务可以是实现了 `Runnable` 接口的对象或实现了 `Callable` 接口的对象. 可以使用线程池的 `execute()` 
方法提交 `Runnable` 任务, 或使用 `submit()` 方法提交 `Callable` 任务.
3. 判断线程池状态: 在执行任务之前, 线程池会检查当前的状态. 通常有以下几种状态: 运行(RUNNING)、关闭(SHUTDOWN)、正在关闭(SHUTTING_DOWN)、
已终止(TERMINATED). 如果线程池处于关闭或正在关闭状态, 将不会接收新的任务.
4. 创建线程并执行任务: 当有任务提交到线程池后, 线程池会根据当前的状态和配置来创建新的线程或复用空闲线程来执行任务. 如果当前线程数少于核心线程数, 线程池
会创建新的线程. 如果核心线程已满且工作队列未满, 任务会被放入工作队列中等待执行. 如果工作队列已满且线程数少于最大线程数, 线程池会创建新的线程执行任务. 
如果线程数达到最大线程数, 且工作队列也已满, 则根据线程池的拒绝策略来处理无法执行的任务.
5. 执行任务: 线程池中的线程会从工作队列中取出任务, 并执行任务的 `run` 方法(对于 `Runnable` 任务) 或获取任务的结构(对于 `Callable` 任务). 执行任务
的过程会重复进行, 直到线程池关闭或没有任务可执行.
6. 完成任务: 当任务执行完成后, 线程会从线程池中被释放, 成为空闲线程, 等待执行新的任务. 如果线程空闲时间超过设定的时间, 则可能被终止并从线程池中移除.
7. 关闭线程池: 当不再需要执行新的任务时, 可以调用线程池的 `shutdown()` 方法来关闭线程池. 关闭线程池会拒绝新任务的提交, 并且等待已提交的任务执行完成.
可以使用 `shutdownNow()` 方法来立即关闭线程池, 并尝试中断正在执行的任务.


四种内置的拒绝策略:
1. `AbortPolicy`(默认): 该策略直接抛出 `RejectedExecutionException` 异常, 阻止任务的提交. 这是默认的拒绝策略, 当线程池无法处理更多任务时,
会立即抛出异常.
2. `CallerRunsPolicy` 该策略不会丢弃任务, 而是将任务回退给调用者线程来执行. 当线程池无法处理更多任务时, 任务会在提交者的线程中执行.
3. `DiscardPolicy` 该策略直接丢弃无法执行的任务, 不给予任何处理. 当线程池无法处理更多任务时, 新提交的任务将被默默地丢弃.
4. `DiscardOldestPolicy` 该策略丢弃工作队列中最旧的任务, 然后尝试再次提交新任务. 当线程池无法处理更多任务时, 新提交的任务将替换掉队列中最旧的任务.


`shutdown` 和 `shutdownNow` 的主要区别, 在于一个只关闭空闲工作线程, 一个关闭所有工作线程. 一个会等待积累的任务完成, 且不投递新任务, 一个直接结束.

这两个方法, 并不会一直等到工作线程关闭, 他们只是改好状态, 就去中断线程, 线程内部会有根据状态, 自行退出的方法. 所以整个线程池的状态流转是靠 `tryTermintate`
方法实现的.

无论是 `shutdown` 和 `shutdownNow` 都会在中断工作线程后, 尝试调用 `tryTerminate`, 但一般没用. 每个工作线程的退出 `finally` 方法, 其实也会调用到
`tryTerminate`. 这就保证了最后一个工作线程结束的时候, 线程状态开始流转成终结。
