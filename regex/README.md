### 元字符
| 代码 | 说明 |
| :---- | :----: |
| . | 匹配除换行符以外的任意字符 |
| \w | 匹配字母或数字或下划线或汉字 |
| \s | 匹配任意的空白符 |
| \d | 匹配数字 |
| \b | 匹配单词的开始或结束 |
| ^ | 匹配字符串的开始 |
| $ | 匹配字符串的结束 |

元字符 `^` 和 `$` 都匹配一个位置, 这和 `\b` 有点类似. `^` 匹配你要用来查找的字符串的开头, `$` 匹配结尾. 比如一个网站如果要求你填写的 QQ 必须为 5 位 到 12 位数字时, 可以使用: `^\d{5, 12}$`. 因为使用了 `^` 和 `$`, 所以输入的整个字符串都要用来和 `\d{5,12}` 来匹配, 也就是说整个输入必须是 5 到 12 个数字, 因此如果输入的 QQ 能匹配这个正则表达式的话, 那就符合要求了. 有时候要分清楚匹配是
字符串有没有符合表达式规则的部分还是说整个字符串都要符合规则.

### 字符转义
如果你想查找元字符本身的话, 比如你查找 `.`, 或者 `*` 就出现了问题: 你没办法指定他们, 因为他们会被解释成别的意思. 这时你就得使用 `\` 来取消这些字符的特殊意义. 因此， 你应该使用 `\.` 和 `\*`. 当然, 要查找 `\` 本身, 你也得用 `\\`
例如 deerchao\.cn 匹配 deerchao.cn, C:\\Windows 匹配 C:\Windows

### 重复
限定符(指定数量的代码, 例如 *, {5, 12} 等):  
常用的限定符

| 代码/语法  | 说明         |
|:-------|:-----------|
| *      | 重复零次或更多次   |
| +      | 重复一次或更多次   |
| ?      | 重复零次或一次    |
| {n}    | 重复 n 次或更多次 |
| {n, m} | 重复 n 到 m 次 |


### 字符类
要想查找数字, 字母或数字, 空白是很简单的, 因为已经有了对应这些字符集合的元字符, 但是如果你想匹配没有预定义元字符的字符集合(比如元音字母 a,e,i,o,u). 应该怎么办? 很简单, 你只需要在方括号里列出他们就行了, 像 `[aeiou]` 就匹配任何一个英文元音字母, `[.?!]`匹配标点符号(.或?或!)  
我们也可以轻松指定一个字符范围, 像 `[0-9]` 代表的含义与 `\d` 就是完全一致的: 一位数字; 同理`[a-z0-9A-Z]` 也完全等同于 `\w`(如果只考虑英文的话).   
\(?0\d{2}[) -]?\d{8}
首先是一个转义字符 `\(`, 他能出现 `0` 次或 `1` 次(?), 然后是一个 `0`, 后面跟着 `2` 个数字 (`\d{2}`), 然后是 `)` 或 `-` 或 `空格` 中的一个, 它出现 1 次或不出现(?), 最后是 8 个数字(\d{8}).

### 分支条件
正则表达式里的 **分支条件**指的是有几种规则, 如果满足其中任意一种规则都应该当成匹配, 具体方法是用 `|` 把不同的规则分隔开.
0\d{2}-\d{8}|0\d{3}-\d{7} 这个表达式能匹配两种以连字号分隔的电话号码: 一种是三位区号, 8位本地号(如 010-12345678), 一种是 4 位区号, 7位本地号(0376-2233445).
\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8} 这个表达式匹配3位区号的电话号码, 其中区号可以用小括号括起来, 也可以不用, 区号与本地号之间可以用连字号或空格间隔, 也可以没有间隔. 你可以试试用分支条件把这个表达式扩展成也支持4位区号的.
\d{5}-\d{4}|\d{5} 这个表达式用于匹配美国的邮政编码. 美国邮编的规则是5位数字, 或者用连字号间隔的9位数字. 之所以要给出这个例子是因为它能说明一个问题: **使用分支条件时, 要注意各个条件的顺序** 如果你把它改成 `\d{5}|\d{5}-\d{4}`的话, 那么就只会匹配 5 位的邮编(以及9位邮编的前5位). 原因是匹配分枝条件时, 将会从左到右地测试每个条件, 如果满足了某个分枝的话, 就不会去再管其他的条件了.

### 分组
我们已经提到了怎么重复单个字符(直接在字符后面加上限定符就行了); 但如果想要重复多个字符又该怎么办? 你可以用小括号来指定 **子表达式**(也叫做**分组**), 然后你就可以指定这个子表达式的重复次数了, 你也可以对子表达式进行其他一些操作(后面会有介绍).
`(\d{1,3}\.){3}\d{1,3}` 是一个简单的 ip 地址匹配表达式. 要理解这个表达式, 请按下列顺序分析它: `\d{1, 3}` 匹配 1 到 3位的数字, `(\d{1, 3}\.){3}`匹配三位数字加上一个英文句号(这个整体也就是这个 **分组**) 重复3次, 最后再加上一个一到三位的数字(`\d{1,3}`).

### 反义
有时需要查找不属于某个能简单定义的字符类的字符. 比如想查找除了数字意外, 其他任意字符都行的情况, 这时需要用到 **反义**:  

| 代码/语法 | 说明 |
| :--- | :---: |
| \W | 匹配任意不是字母, 数字, 下划线, 汉字的字符 |
| \S | 匹配任意不是空白符的字符 | 
| \D | 匹配任意非数字的字符 |
| \B | 匹配不是单词开头或结束的位置 |
| [^x] | 匹配除了 x 以外的任意字符 |
| [^aeiou] | 匹配除了 aeiou 这几个字母以外的任意字符 |

例子: `\S+` 匹配不包含空白符的字符串
     `<a[^>]+>` 匹配用尖括号括起来的以 a 开头的字符串

### 后向引用
使用小括号指定一个子表达式后, **匹配这个子表达式的文本**(也就是此分组捕获的内容)可以在表达式或其他程序中作进一步的处理. 默认情况下, 每个分组会自动拥有一个 **组号**, 规则是: 从左向右, 以分组的左括号为标志, 第一个出现的分组的组号为 1, 第二个为 2, 依此类推.
完整的组号规则:
- 分组 0 对应整个正则表达式
- 实际上组号分配过程是要从左向右扫描两遍的: 第一遍只给未命名组分配, 第二遍只给命名组分配 = . = 因此所有命名组的组号都大于未命名的组号
- 你可以使用 `?:exp` 这样的语法来剥夺一个分组对组号分配的参与权.

**后向引用**用于重复搜索前面某个分组匹配的文本. 例如, `\1` 代表分组 1 匹配的文本.
`\b(\w+)\b\s+\1\b` 可以用来匹配重复的单词, 像 go go, 或者 kitty kitty. 这个表达式首先是一个单词, 也就是单词开始处和结束处之间的大于等于 1 个的字母或数字(`\b(\w+)\b`), 这个单词会被捕获到编号为 1 的分组中, 然后是 1 个或几个空白符(`\s+`), 最后是分组 1 中捕获的内容(也就是前面匹配的那个单词)(`\1`).  
你也可以自己指定子表达式的**组名**. 要指定一个子表达式的组名, 请使用这样的语法: `(?<Word>\w+)`(或者把尖括号换成 `'` 也行: `(?'Word'\w+)`), 这样就把 `\w+` 的组名指定为 `Word` 了. 要反向引用这个分组 **捕获**的内容, 你可以使用 `\k<Word>`, 所以上一个例子也可以写成这样: `\b(?<Word>\w+)\b\s+\k<Word>\b`  
使用小括号的时候, 还有很多特定用途的语法. 下面累出了最常用的一些:  

| 分类  |     代码/语法      | 说明 |
|:----|:--------------:| :---: |
| 捕获  |    `(exp)`     | 匹配 exp, 并捕获文本到自动命名的组里 |
| 捕获  | `(?<name>exp)` | 匹配 exp, 并捕获文本到名称为 name 的组里, 也可以写成 (?'name'exp) |
| 捕获 |   `(?:exp)`    | 匹配 exp, 不捕获匹配的文本, 也不给此分组分配组号 |
| 零宽断言 |   `(?=exp)`    | 匹配 exp 前面的位置 |
| 零宽断言 |   `(?<=exp)`   | 匹配 exp 后面的位置 |
| 零宽断言 | `(?!exp)` | 匹配后面跟的不是 exp 的位置 |
| 零宽断言 | `(?<!exp)` | 匹配前面不是 exp 的位置 |
| 注释 | `(?#comment)` | 这种类型的分组不对正则表达式的处理产生任何影响, 用于提供注释让人阅读 |

> 断言用来声明一个应该为真的事实. 正则表达式中只有当断言为真时才会继续进行匹配.

### 零宽断言
接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西, 也就是说他们像 '\b', `^`, `$`那样用于指定一个位置, 这个位置应该满足一定的条件(即断言), 因此它们也被成为 **零宽断言**.  

`(?=exp)` 也叫 **零宽度正预测先行断言**, 它断言自身出现的位置的后面能匹配表达式 exp. 比如 `\b\w+(?=ing\b)`, 匹配以 ing 结尾的单词的前面部分(除了 ing 以外的部分), 如查找 i'm singing while you're dancing 时, 它会匹配 sing 和 danc.
`(?<=exp) 也叫 **零宽度正回顾后发断言**`, 它断言自身出现的位置的前面能匹配表达式 exp. 比如 `(?<=\bre)\w+\b` 会匹配以 re 开头的单词的后半部分(除了 re 以外的部分), 例如在查找 reading a book 时, 它匹配 ading.  
假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了), 你可以这样查找需要在前面和里面添加逗号的部分: `((?<=\d)\d{3})+\b`, 用它对 1234567890 进行查找时结果是 234567890.  
下面这个例子同时使用了这两种断言: `(?<=\s)\d+(?=\s)` 匹配以空白符间隔的数字(再次强调, 不包括这些空白符).

#### 负向零宽断言
前面我们提到过怎么查找 **不是某个字符或不在某个字符类里的** 的字符的方法(反义). 但是如果我们只是想要 **确保某个字符没有出现, 但并不想去匹配它** 时怎么办? 例如, 如果我们想查找这样的单词--它里面出现了字母 q, 但是 q 后面跟的不是字母 u, 我们可以尝试这样:
`\b\w*q[^u]\w*\b` 匹配包含 **后面不是字母u的字母q的单词**. 但是如果多做测试(或者你思维足够敏锐, 直接就观察出来了), 你会发现, 如果 q 出现在单词的结尾的话, 像 `Iraq`, `Benq`, 这个表达式就会出错. 这是因为 `[^u]` 总要匹配一个字符, 所以如果 q 是单词的最后一个字符的话, 后面的 [^u] 将会匹配 q 后面的单词分隔符(可能是空格, 或者是句号 或其他的什么), 后面的 `\w*\b` 将会匹配下一个单词, 于是 `\b\w*q[^u]\w*\b` 就能匹配整个 `Iraq fighting`. **负向零宽断言**能解决这样的问题, 因为它只匹配一个位置, 并不**消费**任何字符. 现在, 我们可以这样来解决这个问题: `\b\w*q(?!u)\w*\b`.  
     **零宽度负预测先行断言 `(?!exp)`**, 断言此位置的后面不能匹配表达式 exp. 例如: `\d{3}(?!\d)`匹配三位数字, 而且这三位数字的后面不能是数字; `\b((?!abc)\w)+\b` 匹配不包含连续字符串 abc 的单词.
同理, 我们可以用`(?<!exp)`, **零宽度负回顾后发断言**来断言此位置的前面不能匹配表达式 exp: `(?<![a-z])\d{7}` 匹配前面不是小写字母的七位数字.  
一个更复杂的例子: `(?<=<(\w+)>).*(?=<\/\1>)` 匹配不包含属性的简单 `HTML` 标签内里的内容. `(?<=<(\w+)>)` 指定了这样的**前缀**: 被尖括号括起来的单词(比如可能是<b>), 然后是 .*(任意的字符串), 最后是一个**后缀**`(?=<\/\1>)`. 注意后缀里的 `\/`, 它用到了前面提过的字符转移; `\1` 则是一个反向引用, 引用的正式捕获的第一组, 前面的 `(\w+)` 匹配的内容, 这样如果前缀实际上是 `<b>` 的话, 后缀就是 `</b>`了. 整个表达式匹配的是 `<b>` 和 `</b>` 之间的内容(再次提醒, 不包括前缀和后缀本身).

### 注释
小括号的另一种用途是通过语法`(?#comment)` 来包含注释. 例如: `2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)`.
要包含注释的话, 最好是启用 "忽略模式里的空白符"选项, 这样在编写表达式时能任意的添加空格, Tab, 换行, 而实际使用时这些都将被忽略. 启用这个选项后, 在 `#` 后面到这一行结束的所有文本都将被当成注释忽略掉. 例如, 我们可以前面的一个表达式写出这样:  
(?<=    # 断言要匹配的文本的前缀
<(\w+)> # 查找尖括号括起来的内容
        # (即HTML/XML标签)
)       # 前缀结束
.*      # 匹配任意文本
(?=     # 断言要匹配的文本的后缀
<\/\1>  # 查找尖括号括起来的内容
        # 查找尖括号括起来的内容
)       # 后缀结束
