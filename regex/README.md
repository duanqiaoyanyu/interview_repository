### 元字符
| 代码 | 说明 |
| :---- | :----: |
| . | 匹配除换行符以外的任意字符 |
| \w | 匹配字母或数字或下划线或汉字 |
| \s | 匹配任意的空白符 |
| \d | 匹配数字 |
| \b | 匹配单词的开始或结束 |
| ^ | 匹配字符串的开始 |
| $ | 匹配字符串的结束 |

元字符 `^` 和 `$` 都匹配一个位置, 这和 `\b` 有点类似. `^` 匹配你要用来查找的字符串的开头, `$` 匹配结尾. 比如一个网站如果要求你填写的 QQ 必须为 5 位 到 12 位数字时, 可以使用: `^\d{5, 12}$`. 因为使用了 `^` 和 `$`, 所以输入的整个字符串都要用来和 `\d{5,12}` 来匹配, 也就是说整个输入必须是 5 到 12 个数字, 因此如果输入的 QQ 能匹配这个正则表达式的话, 那就符合要求了. 有时候要分清楚匹配是
字符串有没有符合表达式规则的部分还是说整个字符串都要符合规则.

### 字符转义
如果你想查找元字符本身的话, 比如你查找 `.`, 或者 `*` 就出现了问题: 你没办法指定他们, 因为他们会被解释成别的意思. 这时你就得使用 `\` 来取消这些字符的特殊意义. 因此， 你应该使用 `\.` 和 `\*`. 当然, 要查找 `\` 本身, 你也得用 `\\`
例如 deerchao\.cn 匹配 deerchao.cn, C:\\Windows 匹配 C:\Windows

### 重复
限定符(指定数量的代码, 例如 *, {5, 12} 等):  
常用的限定符

| 代码/语法  | 说明         |
|:-------|:-----------|
| *      | 重复零次或更多次   |
| +      | 重复一次或更多次   |
| ?      | 重复零次或一次    |
| {n}    | 重复 n 次或更多次 |
| {n, m} | 重复 n 到 m 次 |


### 字符类
要想查找数字, 字母或数字, 空白是很简单的, 因为已经有了对应这些字符集合的元字符, 但是如果你想匹配没有预定义元字符的字符集合(比如元音字母 a,e,i,o,u). 应该怎么办? 很简单, 你只需要在方括号里列出他们就行了, 像 `[aeiou]` 就匹配任何一个英文元音字母, `[.?!]`匹配标点符号(.或?或!)  
我们也可以轻松指定一个字符范围, 像 `[0-9]` 代表的含义与 `\d` 就是完全一致的: 一位数字; 同理`[a-z0-9A-Z]` 也完全等同于 `\w`(如果只考虑英文的话).   
\(?0\d{2}[) -]?\d{8}
首先是一个转义字符 `\(`, 他能出现 `0` 次或 `1` 次(?), 然后是一个 `0`, 后面跟着 `2` 个数字 (`\d{2}`), 然后是 `)` 或 `-` 或 `空格` 中的一个, 它出现 1 次或不出现(?), 最后是 8 个数字(\d{8}).

### 分支条件
正则表达式里的 **分支条件**指的是有几种规则, 如果满足其中任意一种规则都应该当成匹配, 具体方法是用 `|` 把不同的规则分隔开.
0\d{2}-\d{8}|0\d{3}-\d{7} 这个表达式能匹配两种以连字号分隔的电话号码: 一种是三位区号, 8位本地号(如 010-12345678), 一种是 4 位区号, 7位本地号(0376-2233445).
\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8} 这个表达式匹配3位区号的电话号码, 其中区号可以用小括号括起来, 也可以不用, 区号与本地号之间可以用连字号或空格间隔, 也可以没有间隔. 你可以试试用分支条件把这个表达式扩展成也支持4位区号的.
\d{5}-\d{4}|\d{5} 这个表达式用于匹配美国的邮政编码. 美国邮编的规则是5位数字, 或者用连字号间隔的9位数字. 之所以要给出这个例子是因为它能说明一个问题: **使用分支条件时, 要注意各个条件的顺序** 如果你把它改成 `\d{5}|\d{5}-\d{4}`的话, 那么就只会匹配 5 位的邮编(以及9位邮编的前5位). 原因是匹配分枝条件时, 将会从左到右地测试每个条件, 如果满足了某个分枝的话, 就不会去再管其他的条件了.

### 分组
我们已经提到了怎么重复单个字符(直接在字符后面加上限定符就行了); 但如果想要重复多个字符又该怎么办? 你可以用小括号来指定 **子表达式**(也叫做**分组**), 然后你就可以指定这个子表达式的重复次数了, 你也可以对子表达式进行其他一些操作(后面会有介绍).
`(\d{1,3}\.){3}\d{1,3}` 是一个简单的 ip 地址匹配表达式. 要理解这个表达式, 请按下列顺序分析它: `\d{1, 3}` 匹配 1 到 3位的数字, `(\d{1, 3}\.){3}`匹配三位数字加上一个英文句号(这个整体也就是这个 **分组**) 重复3次, 最后再加上一个一到三位的数字(`\d{1,3}`).

### 反义
有时需要查找不属于某个能简单定义的字符类的字符. 比如想查找除了数字意外, 其他任意字符都行的情况, 这时需要用到 **反义**:  

| 代码/语法 | 说明 |
| :--- | :---: |
| \W | 匹配任意不是字母, 数字, 下划线, 汉字的字符 |
| \S | 匹配任意不是空白符的字符 | 
| \D | 匹配任意非数字的字符 |
| \B | 匹配不是单词开头或结束的位置 |
| [^x] | 匹配除了 x 以外的任意字符 |
| [^aeiou] | 匹配除了 aeiou 这几个字母以外的任意字符 |

例子: `\S+` 匹配不包含空白符的字符串
     `<a[^>]+>` 匹配用尖括号括起来的以 a 开头的字符串

### 后向引用
使用小括号指定一个子表达式后, **匹配这个子表达式的文本**(也就是此分组捕获的内容)可以在表达式或其他程序中作进一步的处理. 默认情况下, 每个分组会自动拥有一个 **组号**, 规则是: 从左向右, 以分组的左括号为标志, 第一个出现的分组的组号为 1, 第二个为 2, 依此类推.
完整的组号规则:
- 分组 0 对应整个正则表达式
- 实际上组号分配过程是要从左向右扫描两遍的: 第一遍只给未命名组分配, 第二遍只给命名组分配 = . = 因此所有命名组的组号都大于未命名的组号
- 你可以使用 `?:exp` 这样的语法来剥夺一个分组对组号分配的参与权.

**后向引用**用于重复搜索前面某个分组匹配的文本. 例如, `\1` 代表分组 1 匹配的文本.
`\b(\w+)\b\s+\1\b` 可以用来匹配重复的单词, 像 go go, 或者 kitty kitty. 这个表达式首先是一个单词, 也就是单词开始处和结束处之间的大于等于 1 个的字母或数字(`\b(\w+)\b`), 这个单词会被捕获到编号为 1 的分组中, 然后是 1 个或几个空白符(`\s+`), 最后是分组 1 中捕获的内容(也就是前面匹配的那个单词)(`\1`).  
你也可以自己指定子表达式的**组名**. 要指定一个子表达式的组名, 请使用这样的语法: `(?<Word>\w+)`(或者把尖括号换成 `'` 也行: `(?'Word'\w+)`), 这样就把 `\w+` 的组名指定为 `Word` 了. 要反向引用这个分组 **捕获**的内容, 你可以使用 `\k<Word>`, 所以上一个例子也可以写成这样: `\b(?<Word>\w+)\b\s+\k<Word>\b`  
使用小括号的时候, 还有很多特定用途的语法. 下面累出了最常用的一些:  

| 分类  |     代码/语法      | 说明 |
|:----|:--------------:| :---: |
| 捕获  |    `(exp)`     | 匹配 exp, 并捕获文本到自动命名的组里 |
| 捕获  | `(?<name>exp)` | 匹配 exp, 并捕获文本到名称为 name 的组里, 也可以写成 (?'name'exp) |
| 捕获 |   `(?:exp)`    | 匹配 exp, 不捕获匹配的文本, 也不给此分组分配组号 |
| 零宽断言 |   `(?=exp)`    | 匹配 exp 前面的位置 |
| 零宽断言 |   `(?<=exp)`   | 匹配 exp 后面的位置 |
| 零宽断言 | `(?!exp)` | 匹配后面跟的不是 exp 的位置 |
| 零宽断言 | `(?<!exp)` | 匹配前面不是 exp 的位置 |
| 注释 | `(?#comment)` | 这种类型的分组不对正则表达式的处理产生任何影响, 用于提供注释让人阅读 |

> 断言用来声明一个应该为真的事实. 正则表达式中只有当断言为真时才会继续进行匹配.

### 零宽断言
接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西, 也就是说他们像 '\b', `^`, `$`那样用于指定一个位置, 这个位置应该满足一定的条件(即断言), 因此它们也被成为 **零宽断言**.  

`(?=exp)` 也叫 **零宽度正预测先行断言**, 它断言自身出现的位置的后面能匹配表达式 exp. 比如 `\b\w+(?=ing\b)`, 匹配以 ing 结尾的单词的前面部分(除了 ing 以外的部分), 如查找 i'm singing while you're dancing 时, 它会匹配 sing 和 danc.
`(?<=exp) 也叫 **零宽度正回顾后发断言**`, 它断言自身出现的位置的前面能匹配表达式 exp. 比如 `(?<=\bre)\w+\b` 会匹配以 re 开头的单词的后半部分(除了 re 以外的部分), 例如在查找 reading a book 时, 它匹配 ading.  
假如你想要给一个很长的数字中每三位间加一个逗号(当然是从右边加起了), 你可以这样查找需要在前面和里面添加逗号的部分: `((?<=\d)\d{3})+\b`, 用它对 1234567890 进行查找时结果是 234567890.  
下面这个例子同时使用了这两种断言: `(?<=\s)\d+(?=\s)` 匹配以空白符间隔的数字(再次强调, 不包括这些空白符).

#### 负向零宽断言
前面我们提到过怎么查找 **不是某个字符或不在某个字符类里的** 的字符的方法(反义). 但是如果我们只是想要 **确保某个字符没有出现, 但并不想去匹配它** 时怎么办? 例如, 如果我们想查找这样的单词--它里面出现了字母 q, 但是 q 后面跟的不是字母 u, 我们可以尝试这样:
`\b\w*q[^u]\w*\b` 匹配包含 **后面不是字母u的字母q的单词**. 但是如果多做测试(或者你思维足够敏锐, 直接就观察出来了), 你会发现, 如果 q 出现在单词的结尾的话, 像 `Iraq`, `Benq`, 这个表达式就会出错. 这是因为 `[^u]` 总要匹配一个字符, 所以如果 q 是单词的最后一个字符的话, 后面的 [^u] 将会匹配 q 后面的单词分隔符(可能是空格, 或者是句号 或其他的什么), 后面的 `\w*\b` 将会匹配下一个单词, 于是 `\b\w*q[^u]\w*\b` 就能匹配整个 `Iraq fighting`. **负向零宽断言**能解决这样的问题, 因为它只匹配一个位置, 并不**消费**任何字符. 现在, 我们可以这样来解决这个问题: `\b\w*q(?!u)\w*\b`.  
     **零宽度负预测先行断言 `(?!exp)`**, 断言此位置的后面不能匹配表达式 exp. 例如: `\d{3}(?!\d)`匹配三位数字, 而且这三位数字的后面不能是数字; `\b((?!abc)\w)+\b` 匹配不包含连续字符串 abc 的单词.
同理, 我们可以用`(?<!exp)`, **零宽度负回顾后发断言**来断言此位置的前面不能匹配表达式 exp: `(?<![a-z])\d{7}` 匹配前面不是小写字母的七位数字.  
一个更复杂的例子: `(?<=<(\w+)>).*(?=<\/\1>)` 匹配不包含属性的简单 `HTML` 标签内里的内容. `(?<=<(\w+)>)` 指定了这样的**前缀**: 被尖括号括起来的单词(比如可能是<b>), 然后是 .*(任意的字符串), 最后是一个**后缀**`(?=<\/\1>)`. 注意后缀里的 `\/`, 它用到了前面提过的字符转移; `\1` 则是一个反向引用, 引用的正式捕获的第一组, 前面的 `(\w+)` 匹配的内容, 这样如果前缀实际上是 `<b>` 的话, 后缀就是 `</b>`了. 整个表达式匹配的是 `<b>` 和 `</b>` 之间的内容(再次提醒, 不包括前缀和后缀本身).

### 注释
小括号的另一种用途是通过语法`(?#comment)` 来包含注释. 例如: `2[0-4]\d(?#200-249)|25[0-5](?#250-255)|[01]?\d\d?(?#0-199)`.
要包含注释的话, 最好是启用 "忽略模式里的空白符"选项, 这样在编写表达式时能任意的添加空格, Tab, 换行, 而实际使用时这些都将被忽略. 启用这个选项后, 在 `#` 后面到这一行结束的所有文本都将被当成注释忽略掉. 例如, 我们可以前面的一个表达式写出这样:  
(?<=    # 断言要匹配的文本的前缀
<(\w+)> # 查找尖括号括起来的内容
        # (即HTML/XML标签)
)       # 前缀结束
.*      # 匹配任意文本
(?=     # 断言要匹配的文本的后缀
<\/\1>  # 查找尖括号括起来的内容
        # 查找尖括号括起来的内容
)       # 后缀结束


### 贪婪与懒惰
当正则表达式中包含能接受重复的限定符时, 通常的行为是(在使整个表达式能得到匹配的前提下) 匹配 **尽可能多**的字符. 以这个表达式为例: `a.*b`, 它将会匹配最长的以 a 开始, 以 b 结束的字符串. 如果用它来搜索 aabb 的话, 它会匹配整个字符串 aabab, 这杯称为 **贪婪**匹配.  
有时, 我们更需要**懒惰**匹配, 也就是匹配**尽可能少**的字符. 前面给出的限定符都可以被转化为懒惰匹配模式, 只要在它后面加上一个问号`?`. 这样 `.*?` 就意味着匹配任意数量的重复, 但是在能使整个匹配成功的前提下使用最少的重复. 现在看看懒惰版的例子吧:  
`a.*?b` 匹配最短的, 以 a 开始, 以 b 结束的字符串. 如果把它应用于 aabab 的话, 它会匹配 aab(第一到第三个字符) 和 ab(第四到第五个字符).

> 为什么第一个匹配是 aab (第一到第三哥字符) 而不是 ab (第二到第三个字符) ? 简单地说, 因为正则表达式有另一条规则, 比懒惰/贪婪规则的优先级更高: 最先开始的匹配拥有最高的优先权 - The match that begins earliest wins.

| 代码/语法 | 说明 |
| :--- | :---: |
| *? | 重复任意次, 但尽可能少重复 |
| +? | 重复 1 次或更多次, 但尽可能少重复 |
| ?? | 重复 0 次或 1 次, 但尽可能少重复 |
| {n, m} ? | 重复 n 到 m 次, 但尽可能少重复 |
| {n, }? | 重复 n 次以上, 但尽可能少重复 |


### 平衡组/递归匹配
有时我们需要匹配像 (100 * (50 + 15)) 这样的可嵌套的层次性结构, 这时简单地使用 `\(.+\)` 则只会匹配到最左边的左括号和最右边的右括号之间的内容(这里我们讨论的是贪婪模式, 懒惰模式也有下面的问题). 加入原来的字符串里的左括号和右括号出现的次数不相等, 比如 (5/(3+2)), 那我们的匹配结果里两者的个数也不会相等. 有没有办法在这样的字符串里匹配到最长的, 配对的括号之间的内容呢?

为了避免 `(` 和 `\(` 把你的大脑彻底搞糊涂, 我们还是用尖括号代替圆括吧. 现在我们的问题变成了如何把 `xx <aa <bbb> <bbb> aa> yy` 这样的字符串里, 最长的配对的尖括号内的内容捕获出来?
    这里需要用到一下的语法构造:
- `(?'group')` 把捕获的内容命名为 group, 并压入 **堆栈(Stack)**
- `(?-'group')` 从堆栈上弹出最后压入堆栈的名为 group 的捕获内容, 如果堆栈本来为空, 则本分组的匹配失败.
- `(?(group)yes|no)` 如果堆栈上存在以名为 group 的捕获内容的话, 继续匹配 yes 部分的表达式, 否则继续匹配 no 部分
- (?!) 零宽负向先行断言, 由于没有后缀表达式, 试图匹配总是失败

我们需要做的是每碰到了左括号, 就在压入一个 "open", 每碰到一个右括号, 就弹出一个, 到了最后就看看堆栈是否为空 = = 如果不为空那就证明左括号比右括号多, 那匹配就应该失败. 正则表达式引擎会进行回溯(放弃最前面或最后面的一些字符), 尽量使整个表达式得到匹配.

<                     #最外面的左括号
[^<>]*                #它后面非括号的内容
(
    (
        (?'Open'<)    #左括号, 压入 "Open"
        [^<>]*        #左括号后面的内容
    )+
    (
        (?'-Open'>)   #右括号, 弹出一个 "Open"
        [^<>]*        #右括号后面的内容
    )+
)*
(?(Open)(?!))         #最外层的右括号前检查
                      #若还有未弹出的 "Open"
                      #则匹配失败
>                     #最外层的右括号  
  
平衡组的一个最常见的应用就是匹配 `HTML`, 下面这个例子可以匹配嵌套的 `<div>` 标签: `<div[^>]*>[^<>]*(((?'Open'<div[^>]*>)[^<>]*)+((?'-Open'</div>)[^<>]*)+)*(?(Open)(?!))</div>`

### 还有些什么东西没提到
上边已经描述了构造正则表达式的大量元素, 但是还有很多没有提到的东西. 下面是一些未提到的元素的列表, 包含语法和简单的说明. 你可以在网上找到更详细的参考资料来学习他们--当你需要用到他们的时候.这里的介绍很简略, 如果你需要更详细的信息

| 代码/语法         | 说明 |
|:--------------| :---: |
| \a            | 报警字符(打印它的效果是电脑嘀一声) |
| \b            | 通常是单词分界位置, 但如果在字符类里使用代表退格 |
| \t            | 制表符, Tab |
| \r            | 回车 |
| \v            | 竖向制表符 |
| \f            | 换页符 |
| \n            | 换行符 |
| \e            | Escape |
| \0nn          | ASCII 代码中八进制代码为 nn 的字符 |
| \xnn          | ASCII 代码中十六进制代码为 nn 的字符 |
| \unnnn        | Unicode 代码中十六进制代码为 nnnn 的字符 |
| \cN           | ASCII 控制字符. 比如 \cC 代表 Ctrl + C |
| \A            | 字符串开头(类似^, 但不受处理多行选项的影响) |
| \Z            | 字符串结尾或行尾(不受处理多行选项的影响) |
| \z            | 字符串结尾(类似$, 但不受处理多行选项的影响) |
| \G            | 当前搜索的开头 |
| \p{name}      | Unicode 中命名为 name 的字符类, 例如 \p{IsGreek} |
| (?>exp)       | 贪婪子表达式 |
| (?<x>-<y>exp) | 平衡组 |
| (?im-nsx:exp) | 在子表达式 exp 中改变处理选项 |
| (?im-nsx)     | 为表达式后面的部分改变处理选项 |
| (?(exp)yes    |no) | 把 exp 当作零宽正向先行断言, 如果在这个位置能匹配, 使用 yes 作为此组的表达式; 否则使用 no |
| (?(exp)yes) | 同上, 知识使用空表达式作为 no |
| (?(name)yes|no) | 如果命名为 name 的组捕获到了内容, 使用 yes 作为表达式; 否则使用 no |
|(?(name)yes) | 同上, 知识使用空表达式作为 no |

