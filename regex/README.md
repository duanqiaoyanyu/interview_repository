### 元字符
| 代码 | 说明 |
| :---- | :----: |
| . | 匹配除换行符以外的任意字符 |
| \w | 匹配字母或数字或下划线或汉字 |
| \s | 匹配任意的空白符 |
| \d | 匹配数字 |
| \b | 匹配单词的开始或结束 |
| ^ | 匹配字符串的开始 |
| $ | 匹配字符串的结束 |

元字符 `^` 和 `$` 都匹配一个位置, 这和 `\b` 有点类似. `^` 匹配你要用来查找的字符串的开头, `$` 匹配结尾. 比如一个网站如果要求你填写的 QQ 必须为 5 位 到 12 位数字时, 可以使用: `^\d{5, 12}$`. 因为使用了 `^` 和 `$`, 所以输入的整个字符串都要用来和 `\d{5,12}` 来匹配, 也就是说整个输入必须是 5 到 12 个数字, 因此如果输入的 QQ 能匹配这个正则表达式的话, 那就符合要求了. 有时候要分清楚匹配是
字符串有没有符合表达式规则的部分还是说整个字符串都要符合规则.

### 字符转义
如果你想查找元字符本身的话, 比如你查找 `.`, 或者 `*` 就出现了问题: 你没办法指定他们, 因为他们会被解释成别的意思. 这时你就得使用 `\` 来取消这些字符的特殊意义. 因此， 你应该使用 `\.` 和 `\*`. 当然, 要查找 `\` 本身, 你也得用 `\\`
例如 deerchao\.cn 匹配 deerchao.cn, C:\\Windows 匹配 C:\Windows

### 重复
限定符(指定数量的代码, 例如 *, {5, 12} 等):  
常用的限定符

| 代码/语法  | 说明         |
|:-------|:-----------|
| *      | 重复零次或更多次   |
| +      | 重复一次或更多次   |
| ?      | 重复零次或一次    |
| {n}    | 重复 n 次或更多次 |
| {n, m} | 重复 n 到 m 次 |


### 字符类
要想查找数字, 字母或数字, 空白是很简单的, 因为已经有了对应这些字符集合的元字符, 但是如果你想匹配没有预定义元字符的字符集合(比如元音字母 a,e,i,o,u). 应该怎么办? 很简单, 你只需要在方括号里列出他们就行了, 像 `[aeiou]` 就匹配任何一个英文元音字母, `[.?!]`匹配标点符号(.或?或!)  
我们也可以轻松指定一个字符范围, 像 `[0-9]` 代表的含义与 `\d` 就是完全一致的: 一位数字; 同理`[a-z0-9A-Z]` 也完全等同于 `\w`(如果只考虑英文的话).   
\(?0\d{2}[) -]?\d{8}
首先是一个转义字符 `\(`, 他能出现 `0` 次或 `1` 次(?), 然后是一个 `0`, 后面跟着 `2` 个数字 (`\d{2}`), 然后是 `)` 或 `-` 或 `空格` 中的一个, 它出现 1 次或不出现(?), 最后是 8 个数字(\d{8}).

### 分支条件
正则表达式里的 **分支条件**指的是有几种规则, 如果满足其中任意一种规则都应该当成匹配, 具体方法是用 `|` 把不同的规则分隔开.
0\d{2}-\d{8}|0\d{3}-\d{7} 这个表达式能匹配两种以连字号分隔的电话号码: 一种是三位区号, 8位本地号(如 010-12345678), 一种是 4 位区号, 7位本地号(0376-2233445).
\(0\d{2}\)[- ]?\d{8}|0\d{2}[- ]?\d{8} 这个表达式匹配3位区号的电话号码, 其中区号可以用小括号括起来, 也可以不用, 区号与本地号之间可以用连字号或空格间隔, 也可以没有间隔. 你可以试试用分支条件把这个表达式扩展成也支持4位区号的.
\d{5}-\d{4}|\d{5} 这个表达式用于匹配美国的邮政编码. 美国邮编的规则是5位数字, 或者用连字号间隔的9位数字. 之所以要给出这个例子是因为它能说明一个问题: **使用分支条件时, 要注意各个条件的顺序** 如果你把它改成 `\d{5}|\d{5}-\d{4}`的话, 那么就只会匹配 5 位的邮编(以及9位邮编的前5位). 原因是匹配分枝条件时, 将会从左到右地测试每个条件, 如果满足了某个分枝的话, 就不会去再管其他的条件了.

### 分组
我们已经提到了怎么重复单个字符(直接在字符后面加上限定符就行了); 但如果想要重复多个字符又该怎么办? 你可以用小括号来指定 **子表达式**(也叫做**分组**), 然后你就可以指定这个子表达式的重复次数了, 你也可以对子表达式进行其他一些操作(后面会有介绍).
`(\d{1,3}\.){3}\d{1,3}` 是一个简单的 ip 地址匹配表达式. 要理解这个表达式, 请按下列顺序分析它: `\d{1, 3}` 匹配 1 到 3位的数字, `(\d{1, 3}\.){3}`匹配三位数字加上一个英文句号(这个整体也就是这个 **分组**) 重复3次, 最后再加上一个一到三位的数字(`\d{1,3}`).

### 反义
有时需要查找不属于某个能简单定义的字符类的字符. 比如想查找除了数字意外, 其他任意字符都行的情况, 这时需要用到 **反义**:  

| 代码/语法 | 说明 |
| :--- | :---: |
| \W | 匹配任意不是字母, 数字, 下划线, 汉字的字符 |
| \S | 匹配任意不是空白符的字符 | 
| \D | 匹配任意非数字的字符 |
| \B | 匹配不是单词开头或结束的位置 |
| [^x] | 匹配除了 x 以外的任意字符 |
| [^aeiou] | 匹配除了 aeiou 这几个字母以外的任意字符 |

例子: `\S+` 匹配不包含空白符的字符串
     `<a[^>]+>` 匹配用尖括号括起来的以 a 开头的字符串

### 后向引用
使用小括号指定一个子表达式后, **匹配这个子表达式的文本**(也就是此分组捕获的内容)可以在表达式或其他程序中作进一步的处理. 默认情况下, 每个分组会自动拥有一个 **组号**, 规则是: 从左向右, 以分组的左括号为标志, 第一个出现的分组的组号为 1, 第二个为 2, 依此类推.
完整的组号规则:
- 分组 0 对应整个正则表达式
- 实际上组号分配过程是要从左向右扫描两遍的: 第一遍只给未命名组分配, 第二遍只给命名组分配 = . = 因此所有命名组的组号都大于未命名的组号
- 你可以使用 `?:exp` 这样的语法来剥夺一个分组对组号分配的参与权.

**后向引用**用于重复搜索前面某个分组匹配的文本. 例如, `\1` 代表分组 1 匹配的文本.
`\b(\w+)\b\s+\1\b` 可以用来匹配重复的单词, 像 go go, 或者 kitty kitty. 这个表达式首先是一个单词, 也就是单词开始处和结束处之间的大于等于 1 个的字母或数字(`\b(\w+)\b`), 这个单词会被捕获到编号为 1 的分组中, 然后是 1 个或几个空白符(`\s+`), 最后是分组 1 中捕获的内容(也就是前面匹配的那个单词)(`\1`).  
你也可以自己指定子表达式的**组名**. 要指定一个子表达式的组名, 请使用这样的语法: `(?<Word>\w+)`(或者把尖括号换成 `'` 也行: `(?'Word'\w+)`), 这样就把 `\w+` 的组名指定为 `Word` 了. 要反向引用这个分组 **捕获**的内容, 你可以使用 `\k<Word>`, 所以上一个例子也可以写成这样: `\b(?<Word>\w+)\b\s+\k<Word>\b`  
使用小括号的时候, 还有很多特定用途的语法. 下面累出了最常用的一些:  

| 分类  |     代码/语法      | 说明 |
|:----|:--------------:| :---: |
| 捕获  |    `(exp)`     | 匹配 exp, 并捕获文本到自动命名的组里 |
| 捕获  | `(?<name>exp)` | 匹配 exp, 并捕获文本到名称为 name 的组里, 也可以写成 (?'name'exp) |
| 捕获 |   `(?:exp)`    | 匹配 exp, 不捕获匹配的文本, 也不给此分组分配组号 |
| 零宽断言 |   `(?=exp)`    | 匹配 exp 前面的位置 |
| 零宽断言 |   `(?<=exp)`   | 匹配 exp 后面的位置 |
| 零宽断言 | `(?!exp)` | 匹配后面跟的不是 exp 的位置 |
| 零宽断言 | `(?<!exp)` | 匹配前面不是 exp 的位置 |
| 注释 | `(?#comment)` | 这种类型的分组不对正则表达式的处理产生任何影响, 用于提供注释让人阅读 |

### 零宽断言
接下来的四个用于查找在某些内容(但并不包括这些内容)之前或之后的东西, 也就是说他们像 '\b', `^`, `$`那样用于指定一个位置, 这个位置应该满足一定的条件(即断言), 因此它们也被成为 **零宽断言**.
